{
    "docs": [
        {
            "location": "/", 
            "text": "About this book\n|\n\n\nElixirBook is an attempt to write a beginner friendly book about \nElixir\n and \nPhoenix\n, which I write to better memorize things myself, because I heard that writing about something is the best way to learn and memorize something better.\n\n\nYou can find the source code for this book at GitHub:\n\nElixirBook\n /\n\nsource\n\n\nInstallation\n|\n\n\nTo install Elixir, follow the \ninstallation guide\n at Elixir's official website.\n\n\nHistory of Elixir\n|\n\n\nIn 2010, a very influential rubyist and Rails core team member Jos\u00e9 Valim started using Erlang for pieces of his Rails apps with higher need for better concurrency. He loved Erlang, but he missed some features, so he decided to create a new programming language which wil run on Erlang VM (BEAM), with all the benefits of Erlang and BEAM but a better syntax and ecosystem.\n\n\nOn Jan 9, 2011 Jos\u00e9 Valim initialized a new git repository for this language and called it Elixir.\n\n\n\n\nAbout the language\n|\n\n\nElixir is a functional, dynamic language designed for easier scalability and maintainability. It runs on Erlang VM which is refined and battle tested for decades. Scalability, concurrency, fault-tolernace and hot code reloading are some of the strengths of the Erlang VM (BEAM).\n\n\nElixir makes creating and scaling web applications a pleasant experience. Elixir and its full-stack framework Phoenix are heaven for Rails, Django, Laravel, Symfony, Play, Spring, Mojolicious and Grails developers, looking for a technology as productive as their previous language/framework but a lot easier to scale vertically and horizontally.\n\n\nTo learn more about Elixir's strengths and features, go to \nElixir's homepage\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#about-this-book", 
            "text": "ElixirBook is an attempt to write a beginner friendly book about  Elixir  and  Phoenix , which I write to better memorize things myself, because I heard that writing about something is the best way to learn and memorize something better.  You can find the source code for this book at GitHub: ElixirBook  / source", 
            "title": "About this book"
        }, 
        {
            "location": "/#installation", 
            "text": "To install Elixir, follow the  installation guide  at Elixir's official website.", 
            "title": "Installation"
        }, 
        {
            "location": "/#history-of-elixir", 
            "text": "In 2010, a very influential rubyist and Rails core team member Jos\u00e9 Valim started using Erlang for pieces of his Rails apps with higher need for better concurrency. He loved Erlang, but he missed some features, so he decided to create a new programming language which wil run on Erlang VM (BEAM), with all the benefits of Erlang and BEAM but a better syntax and ecosystem.  On Jan 9, 2011 Jos\u00e9 Valim initialized a new git repository for this language and called it Elixir.", 
            "title": "History of Elixir"
        }, 
        {
            "location": "/#about-the-language", 
            "text": "Elixir is a functional, dynamic language designed for easier scalability and maintainability. It runs on Erlang VM which is refined and battle tested for decades. Scalability, concurrency, fault-tolernace and hot code reloading are some of the strengths of the Erlang VM (BEAM).  Elixir makes creating and scaling web applications a pleasant experience. Elixir and its full-stack framework Phoenix are heaven for Rails, Django, Laravel, Symfony, Play, Spring, Mojolicious and Grails developers, looking for a technology as productive as their previous language/framework but a lot easier to scale vertically and horizontally.  To learn more about Elixir's strengths and features, go to  Elixir's homepage .", 
            "title": "About the language"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Assuming you already installed Erlang and Elixir, you can run Interactive Elixir Shell (iex) inside your terminal/command line.\n\n\n\n\nOpening command line / terminal (skip if you already know)\n\n\nOn Mac, open terminal by pressing \n\u2318\n + \nspace\n and then typing \nterminal\n to find it. On windows click on the start button and the type \ncmd\n to open command prompt. On Ubuntu press \nctrl\n + \nalt\n + \nt\n to open terminal.\n\n\n\n\nInteractive Elixir\n|\n\n\nOpen command line / terminal, type \niex\n and press enter. It will output the Erlang and Elixir versions and the prompot will change to \niex(1)\n. The number will change every time you execute a new command.\n\n\nIEx is a \nrepl (Read-Eval-Print Loop)\n, it will take a single input, evaluate it and return the result. We can tell it to return some \nstring\n, we can add, subtract, divide and multiply two or more than two numbers and get the result back. We can run elixir's built-in functions inside iex, or we can even write our own functions and modules inside iex, we can also run functions written in some file from iex. A single command we enter iex is called an expression.\n\n\nLet's open iex and enter the following expressions.\n\n\niex\n(\n1\n)\n \n1\n \n+\n \n2\n\n\n3\n\n\niex\n(\n2\n)\n \n5\n \n-\n \n3\n\n\n2\n\n\niex\n(\n3\n)\n \n2\n \n+\n \n2\n \n==\n \n4\n\n\ntrue\n\n\niex\n(\n4\n)\n \n3\n \n*\n \n3\n \n==\n \n10\n\n\nfalse\n\n\niex\n(\n5\n)\n \n3\n \n+\n \n5\n \n!=\n \n20\n\n\ntrue\n\n\niex\n(\n6\n)\n \n8\n \n \n3\n\n\ntrue\n\n\niex\n(\n7\n)\n \n2\n \n+\n \n2\n \n \n3\n\n\ntrue\n\n\niex\n(\n8\n)\n \nlength\n([\n1\n,\n \n2\n,\n \n3\n,\n \n4\n])\n\n\n4\n\n\niex\n(\n9\n)\n \nFloat\n.\nfloor\n(\n15.3373\n,\n \n2\n)\n\n\n15.33\n\n\niex\n(\n10\n)\n \nCalendar.ISO\n.\nleap_year?\n(\n2018\n)\n\n\nfalse\n\n\niex\n(\n11\n)\n \nCalendar.ISO\n.\nleap_year?\n(\n2020\n)\n\n\ntrue\n\n\niex\n(\n12\n)\n \nadd\n \n=\n \nfn\n(\na\n,\n \nb\n)\n \n-\n \na\n \n+\n \nb\n \nend\n\n\n#Function\n12.99386804/2 in :erl_eval.expr/5\n\n\niex\n(\n13\n)\n \nadd\n.\n(\n1\n,\n \n2\n)\n\n\n3\n\n\n\n\n\n\nThe last 6 expressions need explanation. In Elixir a function is enclosed in a module, and when we call that function we have to prepend it with the module name, e.g., in expression #9, \nFloat\n is the name of module and \nfloor\n is the name of function.\n\n\nSometimes we have a module name, then sub-module name and then the function name, like in expression #10 and #11, \nCalendar\n is the name of module, \nIOS\n is the name of sub-module and \nleap_year?\n is the name of function. \n\n\nAnonymous functions are an exception to this rule, like in expression #12 and #13 we define and call an anonymous function respectively. In that case we call the function by putting name of the function, then dot and then the arguments.\n\n\nFunction \nlength\n used in expression #9, have a module named \nKernel\n, but we don't need to prepend name of the module. This kind of functions are inlined by the Elixir compiler into the \n:erlang\n module and are called \nBIFs\n (built-in internal functions), that's why we don't need to prepend the module name to these functions. \nKernel\n module have many \nBIFs\n.", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#interactive-elixir", 
            "text": "Open command line / terminal, type  iex  and press enter. It will output the Erlang and Elixir versions and the prompot will change to  iex(1) . The number will change every time you execute a new command.  IEx is a  repl (Read-Eval-Print Loop) , it will take a single input, evaluate it and return the result. We can tell it to return some  string , we can add, subtract, divide and multiply two or more than two numbers and get the result back. We can run elixir's built-in functions inside iex, or we can even write our own functions and modules inside iex, we can also run functions written in some file from iex. A single command we enter iex is called an expression.  Let's open iex and enter the following expressions.  iex ( 1 )   1   +   2  3  iex ( 2 )   5   -   3  2  iex ( 3 )   2   +   2   ==   4  true  iex ( 4 )   3   *   3   ==   10  false  iex ( 5 )   3   +   5   !=   20  true  iex ( 6 )   8     3  true  iex ( 7 )   2   +   2     3  true  iex ( 8 )   length ([ 1 ,   2 ,   3 ,   4 ])  4  iex ( 9 )   Float . floor ( 15.3373 ,   2 )  15.33  iex ( 10 )   Calendar.ISO . leap_year? ( 2018 )  false  iex ( 11 )   Calendar.ISO . leap_year? ( 2020 )  true  iex ( 12 )   add   =   fn ( a ,   b )   -   a   +   b   end  #Function 12.99386804/2 in :erl_eval.expr/5  iex ( 13 )   add . ( 1 ,   2 )  3   The last 6 expressions need explanation. In Elixir a function is enclosed in a module, and when we call that function we have to prepend it with the module name, e.g., in expression #9,  Float  is the name of module and  floor  is the name of function.  Sometimes we have a module name, then sub-module name and then the function name, like in expression #10 and #11,  Calendar  is the name of module,  IOS  is the name of sub-module and  leap_year?  is the name of function.   Anonymous functions are an exception to this rule, like in expression #12 and #13 we define and call an anonymous function respectively. In that case we call the function by putting name of the function, then dot and then the arguments.  Function  length  used in expression #9, have a module named  Kernel , but we don't need to prepend name of the module. This kind of functions are inlined by the Elixir compiler into the  :erlang  module and are called  BIFs  (built-in internal functions), that's why we don't need to prepend the module name to these functions.  Kernel  module have many  BIFs .", 
            "title": "Interactive Elixir"
        }
    ]
}